# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

loop_esreg_covariance <- function(x, xq, xe, G1_prime_xq, G2_xe, G2_prime_xe, density, conditional_variance, alpha) {
    .Call('esreg_loop_esreg_covariance', PACKAGE = 'esreg', x, xq, xe, G1_prime_xq, G2_xe, G2_prime_xe, density, conditional_variance, alpha)
}

stationary_bootstrap_indices <- function(n, avg_block_size, B) {
    .Call('esreg_stationary_bootstrap_indices', PACKAGE = 'esreg', n, avg_block_size, B)
}

#' Specification Function: G1
#'
#' @param z Data
#' @param type Choice of the G1 function:
#' \itemize{
#'   \item 1: G1(z) = z
#'   \item 2: G1(z) = 0
#' }
#' @export
G1_fun <- function(z, type) {
    .Call('esreg_G1_fun', PACKAGE = 'esreg', z, type)
}

#' Specification Function: G1_prime
#'
#' @param z Data
#' @param type Choice of the G1_prime function:
#' \itemize{
#'   \item 1: G1_prime(z) = 1
#'   \item 2: G1_prime(z) = 0
#' }
#' @export
#' @export
G1_prime_fun <- function(z, type) {
    .Call('esreg_G1_prime_fun', PACKAGE = 'esreg', z, type)
}

#' Specification Function: G2_curly
#'
#' @param z Data
#' @param type Choice of the G2_curly function:
#' \itemize{
#'   \item 1: -log(-z), z < 0
#'   \item 2: -sqrt(-z), z < 0
#'   \item 3: -1/z, z < 0
#'   \item 4: log(1 + exp(z))
#'   \item 5: exp(z)
#' }
#' @export
G2_curly_fun <- function(z, type) {
    .Call('esreg_G2_curly_fun', PACKAGE = 'esreg', z, type)
}

#' Specification Function: G2
#'
#' @param z Data
#' @param type Choice of the G2 function:
#' \itemize{
#'   \item 1: -1/z, z < 0
#'   \item 2: 0.5/sqrt(-z), z < 0
#'   \item 3: 1/z^2, z < 0
#'   \item 4: 1 / (1 + exp(-z))
#'   \item 5: exp(z)
#' }
#' @export
G2_fun <- function(z, type) {
    .Call('esreg_G2_fun', PACKAGE = 'esreg', z, type)
}

#' Specification Function: G2_prime
#'
#' @param z Data
#' @param type Choice of the G2_prime function:
#' \itemize{
#'   \item 1: 1/z^2, z < 0
#'   \item 2: 0.25 / (-z)^(3/2), z < 0
#'   \item 3: -2/z^3, z < 0
#'   \item 4: exp(z) / (1 + exp(z))^2
#'   \item 5: exp(z)
#' }
#' @export
G2_prime_fun <- function(z, type) {
    .Call('esreg_G2_prime_fun', PACKAGE = 'esreg', z, type)
}

#' Vectorized call to the G1/G2 functions
#'
#' @param z Vector
#' @param g G1, G1_prime, G2_curly, G2 or G2_curly
#' @param type G1: 1-2; G2: 1-5
#'
#' @export
G_vec <- function(z, g, type) {
    .Call('esreg_G_vec', PACKAGE = 'esreg', z, g, type)
}

#' Joint (VaR, ES) loss for a linear predictor
#'
#' @param b Parameter vector
#' @param y Vector of dependent data
#' @param x Matrix of covariates. Note: intercept needs to be added manually
#' @param alpha Quantile index
#' @param g1 1, 2 (see \link{G1_fun})
#' @param g2 1, 2, 3, 4, 5 (see \link{G2_curly_fun}, \link{G2_fun})
#' @param delta Approximation of the indicator function (0 is the indicator function)
#' @importFrom Rcpp sourceCpp
#' @useDynLib esreg
#' @export
esr_rho_lp <- function(b, y, x, alpha, g1 = 2L, g2 = 1L, delta = 0) {
    .Call('esreg_esr_rho_lp', PACKAGE = 'esreg', b, y, x, alpha, g1, g2, delta)
}

#' Indentification function for the pair (VaR, ES) for a linear predictor
#'
#' Returns psi' * psi.
#'
#' @param b Parameter vector
#' @param y Vector of dependent data
#' @param x Matrix of covariates. Note: intercept needs to be added manually
#' @param alpha Quantile index
#' @param g1 1, 2 (see \link{G1_prime_fun})
#' @param g2 1, 2, 3, 4, 5 ()see \link{G2_fun}, \link{G2_prime_fun})
#' @param delta Approximation of the indicator function (0 is the indicator function)
#' @importFrom Rcpp sourceCpp
#' @useDynLib esreg
#' @export
esr_psi_lp <- function(b, y, x, alpha, g1 = 2L, g2 = 1L, delta = 0) {
    .Call('esreg_esr_psi_lp', PACKAGE = 'esreg', b, y, x, alpha, g1, g2, delta)
}

